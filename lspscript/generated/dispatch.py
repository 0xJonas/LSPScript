from .util import *
from .enumerations import *
from .structures import *

parse_request_params: Dict[str, Callable[[JSON_VALUE], Any]] = {
    "textDocument/implementation": lambda p: ImplementationParams.from_json(json_assert_type_object(p)),
    "textDocument/typeDefinition": lambda p: TypeDefinitionParams.from_json(json_assert_type_object(p)),
    "workspace/configuration": lambda p: ConfigurationParamsAndPartialResultParams.from_json(json_assert_type_object(p)),
    "textDocument/documentColor": lambda p: DocumentColorParams.from_json(json_assert_type_object(p)),
    "textDocument/colorPresentation": lambda p: ColorPresentationParams.from_json(json_assert_type_object(p)),
    "textDocument/foldingRange": lambda p: FoldingRangeParams.from_json(json_assert_type_object(p)),
    "textDocument/declaration": lambda p: DeclarationParams.from_json(json_assert_type_object(p)),
    "textDocument/selectionRange": lambda p: SelectionRangeParams.from_json(json_assert_type_object(p)),
    "window/workDoneProgress/create": lambda p: WorkDoneProgressCreateParams.from_json(json_assert_type_object(p)),
    "textDocument/prepareCallHierarchy": lambda p: CallHierarchyPrepareParams.from_json(json_assert_type_object(p)),
    "callHierarchy/incomingCalls": lambda p: CallHierarchyIncomingCallsParams.from_json(json_assert_type_object(p)),
    "callHierarchy/outgoingCalls": lambda p: CallHierarchyOutgoingCallsParams.from_json(json_assert_type_object(p)),
    "textDocument/semanticTokens/full": lambda p: SemanticTokensParams.from_json(json_assert_type_object(p)),
    "textDocument/semanticTokens/full/delta": lambda p: SemanticTokensDeltaParams.from_json(json_assert_type_object(p)),
    "textDocument/semanticTokens/range": lambda p: SemanticTokensRangeParams.from_json(json_assert_type_object(p)),
    "window/showDocument": lambda p: ShowDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/linkedEditingRange": lambda p: LinkedEditingRangeParams.from_json(json_assert_type_object(p)),
    "workspace/willCreateFiles": lambda p: CreateFilesParams.from_json(json_assert_type_object(p)),
    "workspace/willRenameFiles": lambda p: RenameFilesParams.from_json(json_assert_type_object(p)),
    "workspace/willDeleteFiles": lambda p: DeleteFilesParams.from_json(json_assert_type_object(p)),
    "textDocument/moniker": lambda p: MonikerParams.from_json(json_assert_type_object(p)),
    "textDocument/prepareTypeHierarchy": lambda p: TypeHierarchyPrepareParams.from_json(json_assert_type_object(p)),
    "typeHierarchy/supertypes": lambda p: TypeHierarchySupertypesParams.from_json(json_assert_type_object(p)),
    "typeHierarchy/subtypes": lambda p: TypeHierarchySubtypesParams.from_json(json_assert_type_object(p)),
    "textDocument/inlineValue": lambda p: InlineValueParams.from_json(json_assert_type_object(p)),
    "textDocument/inlayHint": lambda p: InlayHintParams.from_json(json_assert_type_object(p)),
    "inlayHint/resolve": lambda p: InlayHint.from_json(json_assert_type_object(p)),
    "textDocument/diagnostic": lambda p: DocumentDiagnosticParams.from_json(json_assert_type_object(p)),
    "workspace/diagnostic": lambda p: WorkspaceDiagnosticParams.from_json(json_assert_type_object(p)),
    "client/registerCapability": lambda p: RegistrationParams.from_json(json_assert_type_object(p)),
    "client/unregisterCapability": lambda p: UnregistrationParams.from_json(json_assert_type_object(p)),
    "initialize": lambda p: InitializeParams.from_json(json_assert_type_object(p)),
    "window/showMessageRequest": lambda p: ShowMessageRequestParams.from_json(json_assert_type_object(p)),
    "textDocument/willSaveWaitUntil": lambda p: WillSaveTextDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/completion": lambda p: CompletionParams.from_json(json_assert_type_object(p)),
    "completionItem/resolve": lambda p: CompletionItem.from_json(json_assert_type_object(p)),
    "textDocument/hover": lambda p: HoverParams.from_json(json_assert_type_object(p)),
    "textDocument/signatureHelp": lambda p: SignatureHelpParams.from_json(json_assert_type_object(p)),
    "textDocument/definition": lambda p: DefinitionParams.from_json(json_assert_type_object(p)),
    "textDocument/references": lambda p: ReferenceParams.from_json(json_assert_type_object(p)),
    "textDocument/documentHighlight": lambda p: DocumentHighlightParams.from_json(json_assert_type_object(p)),
    "textDocument/documentSymbol": lambda p: DocumentSymbolParams.from_json(json_assert_type_object(p)),
    "textDocument/codeAction": lambda p: CodeActionParams.from_json(json_assert_type_object(p)),
    "codeAction/resolve": lambda p: CodeAction.from_json(json_assert_type_object(p)),
    "workspace/symbol": lambda p: WorkspaceSymbolParams.from_json(json_assert_type_object(p)),
    "workspaceSymbol/resolve": lambda p: WorkspaceSymbol.from_json(json_assert_type_object(p)),
    "textDocument/codeLens": lambda p: CodeLensParams.from_json(json_assert_type_object(p)),
    "codeLens/resolve": lambda p: CodeLens.from_json(json_assert_type_object(p)),
    "textDocument/documentLink": lambda p: DocumentLinkParams.from_json(json_assert_type_object(p)),
    "documentLink/resolve": lambda p: DocumentLink.from_json(json_assert_type_object(p)),
    "textDocument/formatting": lambda p: DocumentFormattingParams.from_json(json_assert_type_object(p)),
    "textDocument/rangeFormatting": lambda p: DocumentRangeFormattingParams.from_json(json_assert_type_object(p)),
    "textDocument/onTypeFormatting": lambda p: DocumentOnTypeFormattingParams.from_json(json_assert_type_object(p)),
    "textDocument/rename": lambda p: RenameParams.from_json(json_assert_type_object(p)),
    "textDocument/prepareRename": lambda p: PrepareRenameParams.from_json(json_assert_type_object(p)),
    "workspace/executeCommand": lambda p: ExecuteCommandParams.from_json(json_assert_type_object(p)),
    "workspace/applyEdit": lambda p: ApplyWorkspaceEditParams.from_json(json_assert_type_object(p))
}

write_request_params: Dict[str, Callable[[Any], JSON_VALUE]] = {
    "textDocument/implementation": lambda p: p.to_json(),
    "textDocument/typeDefinition": lambda p: p.to_json(),
    "workspace/configuration": lambda p: p.to_json(),
    "textDocument/documentColor": lambda p: p.to_json(),
    "textDocument/colorPresentation": lambda p: p.to_json(),
    "textDocument/foldingRange": lambda p: p.to_json(),
    "textDocument/declaration": lambda p: p.to_json(),
    "textDocument/selectionRange": lambda p: p.to_json(),
    "window/workDoneProgress/create": lambda p: p.to_json(),
    "textDocument/prepareCallHierarchy": lambda p: p.to_json(),
    "callHierarchy/incomingCalls": lambda p: p.to_json(),
    "callHierarchy/outgoingCalls": lambda p: p.to_json(),
    "textDocument/semanticTokens/full": lambda p: p.to_json(),
    "textDocument/semanticTokens/full/delta": lambda p: p.to_json(),
    "textDocument/semanticTokens/range": lambda p: p.to_json(),
    "window/showDocument": lambda p: p.to_json(),
    "textDocument/linkedEditingRange": lambda p: p.to_json(),
    "workspace/willCreateFiles": lambda p: p.to_json(),
    "workspace/willRenameFiles": lambda p: p.to_json(),
    "workspace/willDeleteFiles": lambda p: p.to_json(),
    "textDocument/moniker": lambda p: p.to_json(),
    "textDocument/prepareTypeHierarchy": lambda p: p.to_json(),
    "typeHierarchy/supertypes": lambda p: p.to_json(),
    "typeHierarchy/subtypes": lambda p: p.to_json(),
    "textDocument/inlineValue": lambda p: p.to_json(),
    "textDocument/inlayHint": lambda p: p.to_json(),
    "inlayHint/resolve": lambda p: p.to_json(),
    "textDocument/diagnostic": lambda p: p.to_json(),
    "workspace/diagnostic": lambda p: p.to_json(),
    "client/registerCapability": lambda p: p.to_json(),
    "client/unregisterCapability": lambda p: p.to_json(),
    "initialize": lambda p: p.to_json(),
    "window/showMessageRequest": lambda p: p.to_json(),
    "textDocument/willSaveWaitUntil": lambda p: p.to_json(),
    "textDocument/completion": lambda p: p.to_json(),
    "completionItem/resolve": lambda p: p.to_json(),
    "textDocument/hover": lambda p: p.to_json(),
    "textDocument/signatureHelp": lambda p: p.to_json(),
    "textDocument/definition": lambda p: p.to_json(),
    "textDocument/references": lambda p: p.to_json(),
    "textDocument/documentHighlight": lambda p: p.to_json(),
    "textDocument/documentSymbol": lambda p: p.to_json(),
    "textDocument/codeAction": lambda p: p.to_json(),
    "codeAction/resolve": lambda p: p.to_json(),
    "workspace/symbol": lambda p: p.to_json(),
    "workspaceSymbol/resolve": lambda p: p.to_json(),
    "textDocument/codeLens": lambda p: p.to_json(),
    "codeLens/resolve": lambda p: p.to_json(),
    "textDocument/documentLink": lambda p: p.to_json(),
    "documentLink/resolve": lambda p: p.to_json(),
    "textDocument/formatting": lambda p: p.to_json(),
    "textDocument/rangeFormatting": lambda p: p.to_json(),
    "textDocument/onTypeFormatting": lambda p: p.to_json(),
    "textDocument/rename": lambda p: p.to_json(),
    "textDocument/prepareRename": lambda p: p.to_json(),
    "workspace/executeCommand": lambda p: p.to_json(),
    "workspace/applyEdit": lambda p: p.to_json()
}


parse_request_result: Dict[str, Callable[[JSON_VALUE], Any]] = {
    "textDocument/implementation": lambda p: parse_or_type((p), (lambda v: parse_Definition((v)), lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/typeDefinition": lambda p: parse_or_type((p), (lambda v: parse_Definition((v)), lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "workspace/workspaceFolders": lambda p: parse_or_type((p), (lambda v: [WorkspaceFolder.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "workspace/configuration": lambda p: [parse_LSPAny((i)) for i in json_assert_type_array(p)],
    "textDocument/documentColor": lambda p: [ColorInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/colorPresentation": lambda p: [ColorPresentation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/foldingRange": lambda p: parse_or_type((p), (lambda v: [FoldingRange.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/declaration": lambda p: parse_or_type((p), (lambda v: parse_Declaration((v)), lambda v: [parse_DeclarationLink(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/selectionRange": lambda p: parse_or_type((p), (lambda v: [SelectionRange.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "window/workDoneProgress/create": lambda p: json_assert_type_null(p),
    "textDocument/prepareCallHierarchy": lambda p: parse_or_type((p), (lambda v: [CallHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "callHierarchy/incomingCalls": lambda p: parse_or_type((p), (lambda v: [CallHierarchyIncomingCall.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "callHierarchy/outgoingCalls": lambda p: parse_or_type((p), (lambda v: [CallHierarchyOutgoingCall.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/semanticTokens/full": lambda p: parse_or_type((p), (lambda v: SemanticTokens.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/semanticTokens/full/delta": lambda p: parse_or_type((p), (lambda v: SemanticTokens.from_json(json_assert_type_object(v)), lambda v: SemanticTokensDelta.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/semanticTokens/range": lambda p: parse_or_type((p), (lambda v: SemanticTokens.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "workspace/semanticTokens/refresh": lambda p: json_assert_type_null(p),
    "window/showDocument": lambda p: ShowDocumentResult.from_json(json_assert_type_object(p)),
    "textDocument/linkedEditingRange": lambda p: parse_or_type((p), (lambda v: LinkedEditingRanges.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "workspace/willCreateFiles": lambda p: parse_or_type((p), (lambda v: WorkspaceEdit.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "workspace/willRenameFiles": lambda p: parse_or_type((p), (lambda v: WorkspaceEdit.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "workspace/willDeleteFiles": lambda p: parse_or_type((p), (lambda v: WorkspaceEdit.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/moniker": lambda p: parse_or_type((p), (lambda v: [Moniker.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/prepareTypeHierarchy": lambda p: parse_or_type((p), (lambda v: [TypeHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "typeHierarchy/supertypes": lambda p: parse_or_type((p), (lambda v: [TypeHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "typeHierarchy/subtypes": lambda p: parse_or_type((p), (lambda v: [TypeHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/inlineValue": lambda p: parse_or_type((p), (lambda v: [parse_InlineValue((i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "workspace/inlineValue/refresh": lambda p: json_assert_type_null(p),
    "textDocument/inlayHint": lambda p: parse_or_type((p), (lambda v: [InlayHint.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "inlayHint/resolve": lambda p: InlayHint.from_json(json_assert_type_object(p)),
    "workspace/inlayHint/refresh": lambda p: json_assert_type_null(p),
    "textDocument/diagnostic": lambda p: parse_DocumentDiagnosticReport((p)),
    "workspace/diagnostic": lambda p: WorkspaceDiagnosticReport.from_json(json_assert_type_object(p)),
    "workspace/diagnostic/refresh": lambda p: json_assert_type_null(p),
    "client/registerCapability": lambda p: json_assert_type_null(p),
    "client/unregisterCapability": lambda p: json_assert_type_null(p),
    "initialize": lambda p: InitializeResult.from_json(json_assert_type_object(p)),
    "shutdown": lambda p: json_assert_type_null(p),
    "window/showMessageRequest": lambda p: parse_or_type((p), (lambda v: MessageActionItem.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/willSaveWaitUntil": lambda p: parse_or_type((p), (lambda v: [TextEdit.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/completion": lambda p: parse_or_type((p), (lambda v: [CompletionItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: CompletionList.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "completionItem/resolve": lambda p: CompletionItem.from_json(json_assert_type_object(p)),
    "textDocument/hover": lambda p: parse_or_type((p), (lambda v: Hover.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/signatureHelp": lambda p: parse_or_type((p), (lambda v: SignatureHelp.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/definition": lambda p: parse_or_type((p), (lambda v: parse_Definition((v)), lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/references": lambda p: parse_or_type((p), (lambda v: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/documentHighlight": lambda p: parse_or_type((p), (lambda v: [DocumentHighlight.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/documentSymbol": lambda p: parse_or_type((p), (lambda v: [SymbolInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [DocumentSymbol.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/codeAction": lambda p: parse_or_type((p), (lambda v: [parse_or_type((i), (lambda v: Command.from_json(json_assert_type_object(v)), lambda v: CodeAction.from_json(json_assert_type_object(v)))) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "codeAction/resolve": lambda p: CodeAction.from_json(json_assert_type_object(p)),
    "workspace/symbol": lambda p: parse_or_type((p), (lambda v: [SymbolInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [WorkspaceSymbol.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "workspaceSymbol/resolve": lambda p: WorkspaceSymbol.from_json(json_assert_type_object(p)),
    "textDocument/codeLens": lambda p: parse_or_type((p), (lambda v: [CodeLens.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "codeLens/resolve": lambda p: CodeLens.from_json(json_assert_type_object(p)),
    "workspace/codeLens/refresh": lambda p: json_assert_type_null(p),
    "textDocument/documentLink": lambda p: parse_or_type((p), (lambda v: [DocumentLink.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "documentLink/resolve": lambda p: DocumentLink.from_json(json_assert_type_object(p)),
    "textDocument/formatting": lambda p: parse_or_type((p), (lambda v: [TextEdit.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/rangeFormatting": lambda p: parse_or_type((p), (lambda v: [TextEdit.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/onTypeFormatting": lambda p: parse_or_type((p), (lambda v: [TextEdit.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: json_assert_type_null(v))),
    "textDocument/rename": lambda p: parse_or_type((p), (lambda v: WorkspaceEdit.from_json(json_assert_type_object(v)), lambda v: json_assert_type_null(v))),
    "textDocument/prepareRename": lambda p: parse_or_type((p), (lambda v: parse_PrepareRenameResult((v)), lambda v: json_assert_type_null(v))),
    "workspace/executeCommand": lambda p: parse_or_type((p), (lambda v: parse_LSPAny((v)), lambda v: json_assert_type_null(v))),
    "workspace/applyEdit": lambda p: ApplyWorkspaceEditResult.from_json(json_assert_type_object(p))
}

write_request_result: Dict[str, Callable[[Any], JSON_VALUE]] = {
    "textDocument/implementation": lambda p: write_or_type(p, (lambda i: (isinstance(i, Location)) or (isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location)))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink))), lambda i: i is None), (lambda i: write_Definition(i), lambda i: [write_DefinitionLink(i) for i in i], lambda i: i)),
    "textDocument/typeDefinition": lambda p: write_or_type(p, (lambda i: (isinstance(i, Location)) or (isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location)))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink))), lambda i: i is None), (lambda i: write_Definition(i), lambda i: [write_DefinitionLink(i) for i in i], lambda i: i)),
    "workspace/workspaceFolders": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], WorkspaceFolder))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "workspace/configuration": lambda p: [write_LSPAny(i) for i in p],
    "textDocument/documentColor": lambda p: [i.to_json() for i in p],
    "textDocument/colorPresentation": lambda p: [i.to_json() for i in p],
    "textDocument/foldingRange": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], FoldingRange))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/declaration": lambda p: write_or_type(p, (lambda i: (isinstance(i, Location)) or (isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location)))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink))), lambda i: i is None), (lambda i: write_Declaration(i), lambda i: [write_DeclarationLink(i) for i in i], lambda i: i)),
    "textDocument/selectionRange": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], SelectionRange))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "window/workDoneProgress/create": lambda p: p,
    "textDocument/prepareCallHierarchy": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], CallHierarchyItem))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "callHierarchy/incomingCalls": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], CallHierarchyIncomingCall))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "callHierarchy/outgoingCalls": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], CallHierarchyOutgoingCall))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/semanticTokens/full": lambda p: write_or_type(p, (lambda i: isinstance(i, SemanticTokens), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/semanticTokens/full/delta": lambda p: write_or_type(p, (lambda i: isinstance(i, SemanticTokens), lambda i: isinstance(i, SemanticTokensDelta), lambda i: i is None), (lambda i: i.to_json(), lambda i: i.to_json(), lambda i: i)),
    "textDocument/semanticTokens/range": lambda p: write_or_type(p, (lambda i: isinstance(i, SemanticTokens), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "workspace/semanticTokens/refresh": lambda p: p,
    "window/showDocument": lambda p: p.to_json(),
    "textDocument/linkedEditingRange": lambda p: write_or_type(p, (lambda i: isinstance(i, LinkedEditingRanges), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "workspace/willCreateFiles": lambda p: write_or_type(p, (lambda i: isinstance(i, WorkspaceEdit), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "workspace/willRenameFiles": lambda p: write_or_type(p, (lambda i: isinstance(i, WorkspaceEdit), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "workspace/willDeleteFiles": lambda p: write_or_type(p, (lambda i: isinstance(i, WorkspaceEdit), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/moniker": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Moniker))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/prepareTypeHierarchy": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TypeHierarchyItem))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "typeHierarchy/supertypes": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TypeHierarchyItem))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "typeHierarchy/subtypes": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TypeHierarchyItem))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/inlineValue": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or ((isinstance(i[0], InlineValueText)) or (isinstance(i[0], InlineValueVariableLookup)) or (isinstance(i[0], InlineValueEvaluatableExpression)))), lambda i: i is None), (lambda i: [write_InlineValue(i) for i in i], lambda i: i)),
    "workspace/inlineValue/refresh": lambda p: p,
    "textDocument/inlayHint": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], InlayHint))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "inlayHint/resolve": lambda p: p.to_json(),
    "workspace/inlayHint/refresh": lambda p: p,
    "textDocument/diagnostic": lambda p: write_DocumentDiagnosticReport(p),
    "workspace/diagnostic": lambda p: p.to_json(),
    "workspace/diagnostic/refresh": lambda p: p,
    "client/registerCapability": lambda p: p,
    "client/unregisterCapability": lambda p: p,
    "initialize": lambda p: p.to_json(),
    "shutdown": lambda p: p,
    "window/showMessageRequest": lambda p: write_or_type(p, (lambda i: isinstance(i, MessageActionItem), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/willSaveWaitUntil": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TextEdit))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/completion": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], CompletionItem))), lambda i: isinstance(i, CompletionList), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i.to_json(), lambda i: i)),
    "completionItem/resolve": lambda p: p.to_json(),
    "textDocument/hover": lambda p: write_or_type(p, (lambda i: isinstance(i, Hover), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/signatureHelp": lambda p: write_or_type(p, (lambda i: isinstance(i, SignatureHelp), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/definition": lambda p: write_or_type(p, (lambda i: (isinstance(i, Location)) or (isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location)))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink))), lambda i: i is None), (lambda i: write_Definition(i), lambda i: [write_DefinitionLink(i) for i in i], lambda i: i)),
    "textDocument/references": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/documentHighlight": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], DocumentHighlight))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/documentSymbol": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], SymbolInformation))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], DocumentSymbol))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/codeAction": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or ((isinstance(i[0], Command)) or (isinstance(i[0], CodeAction)))), lambda i: i is None), (lambda i: [write_or_type(i, (lambda i: isinstance(i, Command), lambda i: isinstance(i, CodeAction)), (lambda i: i.to_json(), lambda i: i.to_json())) for i in i], lambda i: i)),
    "codeAction/resolve": lambda p: p.to_json(),
    "workspace/symbol": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], SymbolInformation))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], WorkspaceSymbol))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: [i.to_json() for i in i], lambda i: i)),
    "workspaceSymbol/resolve": lambda p: p.to_json(),
    "textDocument/codeLens": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], CodeLens))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "codeLens/resolve": lambda p: p.to_json(),
    "workspace/codeLens/refresh": lambda p: p,
    "textDocument/documentLink": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], DocumentLink))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "documentLink/resolve": lambda p: p.to_json(),
    "textDocument/formatting": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TextEdit))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/rangeFormatting": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TextEdit))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/onTypeFormatting": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], TextEdit))), lambda i: i is None), (lambda i: [i.to_json() for i in i], lambda i: i)),
    "textDocument/rename": lambda p: write_or_type(p, (lambda i: isinstance(i, WorkspaceEdit), lambda i: i is None), (lambda i: i.to_json(), lambda i: i)),
    "textDocument/prepareRename": lambda p: write_or_type(p, (lambda i: (isinstance(i, Range)) or (isinstance(i, Dict) and "range" in i.keys() and "placeholder" in i.keys()) or (isinstance(i, Dict) and "defaultBehavior" in i.keys()), lambda i: i is None), (lambda i: write_PrepareRenameResult(i), lambda i: i)),
    "workspace/executeCommand": lambda p: write_or_type(p, (lambda i: True, lambda i: i is None), (lambda i: write_LSPAny(i), lambda i: i)),
    "workspace/applyEdit": lambda p: p.to_json()
}


parse_request_partial_result: Dict[str, Callable[[JSON_VALUE], Any]] = {
    "textDocument/implementation": lambda p: parse_or_type((p), (lambda v: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/typeDefinition": lambda p: parse_or_type((p), (lambda v: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/documentColor": lambda p: [ColorInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/colorPresentation": lambda p: [ColorPresentation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/foldingRange": lambda p: [FoldingRange.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/declaration": lambda p: parse_or_type((p), (lambda v: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [parse_DeclarationLink(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/selectionRange": lambda p: [SelectionRange.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "callHierarchy/incomingCalls": lambda p: [CallHierarchyIncomingCall.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "callHierarchy/outgoingCalls": lambda p: [CallHierarchyOutgoingCall.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/semanticTokens/full": lambda p: SemanticTokensPartialResult.from_json(json_assert_type_object(p)),
    "textDocument/semanticTokens/full/delta": lambda p: parse_or_type((p), (lambda v: SemanticTokensPartialResult.from_json(json_assert_type_object(v)), lambda v: SemanticTokensDeltaPartialResult.from_json(json_assert_type_object(v)))),
    "textDocument/semanticTokens/range": lambda p: SemanticTokensPartialResult.from_json(json_assert_type_object(p)),
    "textDocument/moniker": lambda p: [Moniker.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "typeHierarchy/supertypes": lambda p: [TypeHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "typeHierarchy/subtypes": lambda p: [TypeHierarchyItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/inlineValue": lambda p: [parse_InlineValue((i)) for i in json_assert_type_array(p)],
    "textDocument/inlayHint": lambda p: [InlayHint.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/diagnostic": lambda p: DocumentDiagnosticReportPartialResult.from_json(json_assert_type_object(p)),
    "workspace/diagnostic": lambda p: WorkspaceDiagnosticReportPartialResult.from_json(json_assert_type_object(p)),
    "textDocument/completion": lambda p: [CompletionItem.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/definition": lambda p: parse_or_type((p), (lambda v: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [parse_DefinitionLink(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/references": lambda p: [Location.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/documentHighlight": lambda p: [DocumentHighlight.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/documentSymbol": lambda p: parse_or_type((p), (lambda v: [SymbolInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [DocumentSymbol.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/codeAction": lambda p: [parse_or_type((i), (lambda v: Command.from_json(json_assert_type_object(v)), lambda v: CodeAction.from_json(json_assert_type_object(v)))) for i in json_assert_type_array(p)],
    "workspace/symbol": lambda p: parse_or_type((p), (lambda v: [SymbolInformation.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)], lambda v: [WorkspaceSymbol.from_json(json_assert_type_object(i)) for i in json_assert_type_array(v)])),
    "textDocument/codeLens": lambda p: [CodeLens.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)],
    "textDocument/documentLink": lambda p: [DocumentLink.from_json(json_assert_type_object(i)) for i in json_assert_type_array(p)]
}

write_request_partial_result: Dict[str, Callable[[Any], JSON_VALUE]] = {
    "textDocument/implementation": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink)))), (lambda i: [i.to_json() for i in i], lambda i: [write_DefinitionLink(i) for i in i])),
    "textDocument/typeDefinition": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink)))), (lambda i: [i.to_json() for i in i], lambda i: [write_DefinitionLink(i) for i in i])),
    "textDocument/documentColor": lambda p: [i.to_json() for i in p],
    "textDocument/colorPresentation": lambda p: [i.to_json() for i in p],
    "textDocument/foldingRange": lambda p: [i.to_json() for i in p],
    "textDocument/declaration": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink)))), (lambda i: [i.to_json() for i in i], lambda i: [write_DeclarationLink(i) for i in i])),
    "textDocument/selectionRange": lambda p: [i.to_json() for i in p],
    "callHierarchy/incomingCalls": lambda p: [i.to_json() for i in p],
    "callHierarchy/outgoingCalls": lambda p: [i.to_json() for i in p],
    "textDocument/semanticTokens/full": lambda p: p.to_json(),
    "textDocument/semanticTokens/full/delta": lambda p: write_or_type(p, (lambda i: isinstance(i, SemanticTokensPartialResult), lambda i: isinstance(i, SemanticTokensDeltaPartialResult)), (lambda i: i.to_json(), lambda i: i.to_json())),
    "textDocument/semanticTokens/range": lambda p: p.to_json(),
    "textDocument/moniker": lambda p: [i.to_json() for i in p],
    "typeHierarchy/supertypes": lambda p: [i.to_json() for i in p],
    "typeHierarchy/subtypes": lambda p: [i.to_json() for i in p],
    "textDocument/inlineValue": lambda p: [write_InlineValue(i) for i in p],
    "textDocument/inlayHint": lambda p: [i.to_json() for i in p],
    "textDocument/diagnostic": lambda p: p.to_json(),
    "workspace/diagnostic": lambda p: p.to_json(),
    "textDocument/completion": lambda p: [i.to_json() for i in p],
    "textDocument/definition": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], Location))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], LocationLink)))), (lambda i: [i.to_json() for i in i], lambda i: [write_DefinitionLink(i) for i in i])),
    "textDocument/references": lambda p: [i.to_json() for i in p],
    "textDocument/documentHighlight": lambda p: [i.to_json() for i in p],
    "textDocument/documentSymbol": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], SymbolInformation))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], DocumentSymbol)))), (lambda i: [i.to_json() for i in i], lambda i: [i.to_json() for i in i])),
    "textDocument/codeAction": lambda p: [write_or_type(i, (lambda i: isinstance(i, Command), lambda i: isinstance(i, CodeAction)), (lambda i: i.to_json(), lambda i: i.to_json())) for i in p],
    "workspace/symbol": lambda p: write_or_type(p, (lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], SymbolInformation))), lambda i: isinstance(i, List) and (len(i) == 0 or (isinstance(i[0], WorkspaceSymbol)))), (lambda i: [i.to_json() for i in i], lambda i: [i.to_json() for i in i])),
    "textDocument/codeLens": lambda p: [i.to_json() for i in p],
    "textDocument/documentLink": lambda p: [i.to_json() for i in p]
}


parse_notification_params: Dict[str, Callable[[JSON_VALUE], Any]] = {
    "workspace/didChangeWorkspaceFolders": lambda p: DidChangeWorkspaceFoldersParams.from_json(json_assert_type_object(p)),
    "window/workDoneProgress/cancel": lambda p: WorkDoneProgressCancelParams.from_json(json_assert_type_object(p)),
    "workspace/didCreateFiles": lambda p: CreateFilesParams.from_json(json_assert_type_object(p)),
    "workspace/didRenameFiles": lambda p: RenameFilesParams.from_json(json_assert_type_object(p)),
    "workspace/didDeleteFiles": lambda p: DeleteFilesParams.from_json(json_assert_type_object(p)),
    "notebookDocument/didOpen": lambda p: DidOpenNotebookDocumentParams.from_json(json_assert_type_object(p)),
    "notebookDocument/didChange": lambda p: DidChangeNotebookDocumentParams.from_json(json_assert_type_object(p)),
    "notebookDocument/didSave": lambda p: DidSaveNotebookDocumentParams.from_json(json_assert_type_object(p)),
    "notebookDocument/didClose": lambda p: DidCloseNotebookDocumentParams.from_json(json_assert_type_object(p)),
    "initialized": lambda p: InitializedParams.from_json(json_assert_type_object(p)),
    "workspace/didChangeConfiguration": lambda p: DidChangeConfigurationParams.from_json(json_assert_type_object(p)),
    "window/showMessage": lambda p: ShowMessageParams.from_json(json_assert_type_object(p)),
    "window/logMessage": lambda p: LogMessageParams.from_json(json_assert_type_object(p)),
    "telemetry/event": lambda p: parse_LSPAny((p)),
    "textDocument/didOpen": lambda p: DidOpenTextDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/didChange": lambda p: DidChangeTextDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/didClose": lambda p: DidCloseTextDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/didSave": lambda p: DidSaveTextDocumentParams.from_json(json_assert_type_object(p)),
    "textDocument/willSave": lambda p: WillSaveTextDocumentParams.from_json(json_assert_type_object(p)),
    "workspace/didChangeWatchedFiles": lambda p: DidChangeWatchedFilesParams.from_json(json_assert_type_object(p)),
    "textDocument/publishDiagnostics": lambda p: PublishDiagnosticsParams.from_json(json_assert_type_object(p)),
    "$/setTrace": lambda p: SetTraceParams.from_json(json_assert_type_object(p)),
    "$/logTrace": lambda p: LogTraceParams.from_json(json_assert_type_object(p)),
    "$/cancelRequest": lambda p: CancelParams.from_json(json_assert_type_object(p)),
    "$/progress": lambda p: ProgressParams.from_json(json_assert_type_object(p))
}

write_notification_params: Dict[str, Callable[[Any], JSON_VALUE]] = {
    "workspace/didChangeWorkspaceFolders": lambda p: p.to_json(),
    "window/workDoneProgress/cancel": lambda p: p.to_json(),
    "workspace/didCreateFiles": lambda p: p.to_json(),
    "workspace/didRenameFiles": lambda p: p.to_json(),
    "workspace/didDeleteFiles": lambda p: p.to_json(),
    "notebookDocument/didOpen": lambda p: p.to_json(),
    "notebookDocument/didChange": lambda p: p.to_json(),
    "notebookDocument/didSave": lambda p: p.to_json(),
    "notebookDocument/didClose": lambda p: p.to_json(),
    "initialized": lambda p: p.to_json(),
    "workspace/didChangeConfiguration": lambda p: p.to_json(),
    "window/showMessage": lambda p: p.to_json(),
    "window/logMessage": lambda p: p.to_json(),
    "telemetry/event": lambda p: write_LSPAny(p),
    "textDocument/didOpen": lambda p: p.to_json(),
    "textDocument/didChange": lambda p: p.to_json(),
    "textDocument/didClose": lambda p: p.to_json(),
    "textDocument/didSave": lambda p: p.to_json(),
    "textDocument/willSave": lambda p: p.to_json(),
    "workspace/didChangeWatchedFiles": lambda p: p.to_json(),
    "textDocument/publishDiagnostics": lambda p: p.to_json(),
    "$/setTrace": lambda p: p.to_json(),
    "$/logTrace": lambda p: p.to_json(),
    "$/cancelRequest": lambda p: p.to_json(),
    "$/progress": lambda p: p.to_json()
}
